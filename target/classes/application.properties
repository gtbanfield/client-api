# Logging
logging.file=app.log
server.port=8080
server.servlet.contextPath=/client-api/v1.0
# Spring Security default user name and password
spring.security.user.name=actuator
spring.security.user.password=actuator
spring.security.user.roles=ACTUATOR_ADMIN

# INFO ENDPOINT CONFIGURATION
info.app.name=actuator-demo
info.app.description=Spring Boot Actuator Demo Project
info.app.version=0.0.1-SNAPSHOT
info.app.encoding=UTF-8
info.app.java.version=17.0.13

# SHUTDOWN ENDPOINT (ShutdownEndpoint)
management.endpoint.shutdown.enabled=true

# HEALTH ENDPOINT
management.endpoint.health.show-details=always

# ENDPOINTS WEB CONFIGURATION
management.endpoints.web.exposure.include=*
spring.security.enabled=false


spring.datasource.url=jdbc:mysql://127.0.0.1:3306/my_database
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver




#1. Use Workload Identity (Recommended)
#Instead of using explicit credentials, enable Workload Identity so your GKE service account can authenticate directly:
#
#sh
#gcloud container clusters update your-cluster \
#  --workload-pool=your-project.svc.id.goog
#
#2. Bind IAM Roles to the GKE Service Account
#Make sure your service account has the correct permissions to access Cloud SQL:
#
#sh
#gcloud projects add-iam-policy-binding your-project-id \
#  --member="serviceAccount:your-gke-sa@your-project-id.iam.gserviceaccount.com" \
#  --role="roles/cloudsql.client"
#
#3. Modify the Database Connection URL
#Since Cloud SQL Auth Proxy runs inside your GKE cluster as a sidecar container, update application.properties:
#
#properties
#spring.datasource.url=jdbc:mysql://127.0.0.1:3306/my_database
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#
#You do not need a username or password when using IAM authentication.
#
#4. Deploy Cloud SQL Auth Proxy as a Sidecar
#Inside your Kubernetes deployment YAML, add the proxy container:
#
#yaml
#containers:
#- name: cloud-sql-auth-proxy
#image: gcr.io/cloudsql-docker/gce-proxy:latest
#args:
#- "--instances=your-project-id:your-region:your-instance-name=tcp:3306"
#securityContext:
#runAsNonRoot: true
#
#5. Test Your Connection
#Once deployed, check if your application can connect:
#
#sh
#kubectl logs -f <pod-name>


#--- Work load identity
1. Enable Workload Identity on Your GKE Cluster
Run the following command to update your cluster:

sh
gcloud container clusters update YOUR_CLUSTER_NAME \
    --region YOUR_REGION \
    --workload-pool=YOUR_PROJECT_ID.svc.id.goog
This sets up Workload Identity Federation, allowing Kubernetes service accounts to authenticate as IAM service accounts.

2. Create an IAM Service Account
sh
gcloud iam service-accounts create gke-workload-sa \
    --display-name "GKE Workload Identity Service Account"

3. Bind IAM Roles to the Service Account
Grant necessary permissions to the IAM service account:

sh
gcloud projects add-iam-policy-binding YOUR_PROJECT_ID \
    --member="serviceAccount:gke-workload-sa@YOUR_PROJECT_ID.iam.gserviceaccount.com" \
    --role="roles/cloudsql.client"

4. Link Kubernetes Service Account to IAM Service Account
sh
kubectl create serviceaccount k8s-sa
gcloud iam service-accounts add-iam-policy-binding gke-workload-sa@YOUR_PROJECT_ID.iam.gserviceaccount.com \
    --member="serviceAccount:YOUR_PROJECT_ID.svc.id.goog[k8s-namespace/k8s-sa]" \
    --role="roles/iam.workloadIdentityUser"
5. Update Kubernetes Deployment to Use Workload Identity
Modify your Pod spec to use the Kubernetes service account:

yaml
serviceAccountName: k8s-sa


#
#The Workload Identity pool name (your-project.svc.id.goog) is automatically generated when you enable Workload Identity for your GKE cluster. You can retrieve it by running:
#
#sh
#gcloud container clusters describe YOUR_CLUSTER_NAME --region YOUR_REGION | grep workloadPool
#Steps to Find Your Workload Identity Pool
#Open Cloud Shell or use the Google Cloud SDK on your local machine.
#
#Run the command:
#
#sh
#gcloud container clusters describe YOUR_CLUSTER_NAME --region YOUR_REGION
#Look for the field:
#
#yaml
#workloadPool: your-project.svc.id.goog